<script setup>
import {useRouter} from 'vue-router'
import bombSound  from '../sound/bomba.mp3'
import crono from '../sound/crono.mp3'
import error from '../sound/error.mp3'
import { io } from "socket.io-client";
import { ref, onMounted, onUnmounted, watch, onBeforeMount} from 'vue';
import bomba from '../assets/bomba.png'
import corz from '../assets/crz.png'
import flecha from '../assets/flecha.png'
import win from '../assets/win.png'
let props = defineProps(['name'])
let canvas = ref(null);
let noLive = ref([])
let ctx = ref(null)
let palabra = ref('')
let palVivo = ref('')
let user = ref('')
let turno = ref('')
let angPer = ref([])
let silaba = ref('')
let personas = ref([])
let personsName = ref([])
let contador = ref(0);
let time = ref(0)
let ganador = ref('')
let currentPlayer = ref(0);
let countdownInterval = null;
let animate = null;
let escala = true

const router = useRouter();
const socket = io("https://serverboomparty.onrender.com/")    //PARA DEPLOY
/* const socket = io("http://localhost:3002/") */

const errors = new Audio(error)
const bomb = new Audio(bombSound) 
bomb.volume = 0.3
const bombImg = new Image();
bombImg.src = bomba
onMounted(() => {
  ctx.value = canvas.value.getContext('2d');  
  socket.emit("name", props.name)
  socket.emit("generate")
  const centerX = canvas.value.width / 2;
  const centerY = canvas.value.height / 2;

  socket.on('sil', data=>{
    const sil = data.normalize('NFD').replace(/[\u0300-\u036f]/g, "");
    if(sil.length === 0 || sil.includes(',') || sil.includes('-')){
      return socket.emit("generate")
    }
    silaba.value = sil.toLowerCase()
    ctx.value.font = '30px Arial'
    ctx.value.fillStyle= 'white'
    console.log(sil);
    ctx.value.textAlign = 'center'
    ctx.value.clearRect(centerX-15,centerY+65,70, 50)
    ctx.value.fillText(sil,centerX+15,centerY+100)
  })

  watch(turno,()=>{
      angPer.value.forEach(persona => {
        ctx.value.clearRect(persona.x-20,persona.y-55,40,30)
        if(persona.name === turno.value){
          const fetch = new Image();
          fetch.src = flecha
          fetch.onload= ()=>{
            ctx.value.drawImage(fetch,persona.x-15,persona.y-50,30,20)
          }
        }
      });
      let form = document.querySelector("#field")
      form.disabled = false
      if(props.name !== turno.value || personas.value[currentPlayer.value].vidas===0){
       return form.disabled = true
      }
    })
  
  socket.on('people', data=>{
    console.log('personas: ' + data);
    ctx.value.clearRect(0,0,canvas.value?.width, canvas.value?.height)
    personas.value = data
    data.forEach(persona =>{
      personsName.value = [...personsName.value, persona.name]
      personsName.value = new Set(personsName.value)
      personsName.value =  [...personsName.value]
    })
    
    bombImg.src = bomba
    bombImg.onload= ()=>{
      ctx.value.drawImage(bombImg,centerX-45,centerY-60,100,100)
    }

    const radius = 180;
    const angleStep = (Math.PI * 2) / data.length;
    
    angPer.value = []
    personas.value.forEach((person,index) => {
      const angle = index * angleStep;
      const x = centerX + Math.cos(angle) * radius;
      const y = centerY + Math.sin(angle) * radius;
      angPer.value = [...angPer.value, {name: person.name, x: x, y: y}]
      console.log(angPer.value);
      ctx.value.beginPath();
      ctx.value.arc(x, y, 25, 0, Math.PI*2);
      ctx.value.fillStyle='white';
      ctx.value.fill();
      ctx.value.closePath();
      ctx.value.font = '16px Arial'
      ctx.value.fillStyle= 'black'
      ctx.value.textAlign = 'center'
      ctx.value.fillText(person.name, x, y+6)
      socket.on('envivo', data=>{
        palVivo.value= data
      })
      
    })
  })
  socket.on('user', (data) =>{
    user.value = data
  });

  socket.on('sound', ()=>{
    if(noLive.value.length===personas.value.length-1)return
    let cronometro = new Audio(crono)
    cronometro.volume = 0.3
    cronometro.play()
  })

  socket.on('changeTurn', (nextPlayer) => {
    if(personas.value.length==1 || noLive.value.length===personas.value.length-1){
      clearInterval(countdownInterval);
      return socket.emit('endGame')
    }
    clearInterval(animate)
    socket.emit('sound')
    vidas()
    animate = setInterval(animateBomb,300)
    if(noLive.value.includes(nextPlayer)){
      return endTurn();
    }
    turno.value = nextPlayer
    // Reiniciar el temporizador para el nuevo turno
    resetTimer();
  });



  const vidas =()=>{
  personas.value.forEach((persona,index) => {
    
    const crz = new Image();
    crz.src = corz
    crz.onload= ()=>{
      ctx.value.clearRect(angPer.value[index].x-21,angPer.value[index].y+30,100,20)
      for(let i = 1; i <= persona.vidas; i++){
        ctx.value.drawImage(crz,i<=1?angPer.value[index].x-21:angPer.value[index].x+1,angPer.value[index].y+30,20,20)
      }
  }
})
}

socket.on('updateVidas',(data)=>{
  personas.value = data
  bomb.play();
  vidas()
})

socket.on('updateNoLive',(data)=>{
  noLive.value = data
})

const animateBomb = ()=>{
  /* ctx.value.clearRect(centerX-55,centerY-62,120, 110) */
  bombImg.src = bomba
  bombImg.onload= ()=>{
    if(escala){
      ctx.value.clearRect(centerX-55,centerY-68,120, 120)
      /* ctx.value.fillRect(centerX-55,centerY-68,120, 120) */
      ctx.value.drawImage(bombImg,centerX-45,centerY-60,100,100)
      escala = false
    }else{
      ctx.value.clearRect(centerX-55,centerY-68,120, 120)
      /* ctx.value.fillRect(centerX-55,centerY-68,120, 120) */
      ctx.value.drawImage(bombImg,centerX-50,centerY-65,115,115)
      escala = true
    }
  }
}



const timer = ()=>{
  //NEW
  if(noLive.value.length===personas.value.length-1)return
  
  personas.value.forEach((person, index)=> {
    if(person.name === props.name){
      currentPlayer.value = index
    }
  });
  let countdown = 10;
  countdownInterval = setInterval(() => {
    
    if(props.name === turno.value){
      countdown--;
      socket.emit('count', countdown)
      console.log('Tiempo restante:', countdown);
    }
    if (countdown <= 0) {
      // El tiempo ha expirado, pasar al siguiente jugador automÃ¡ticamente
      endTurn();
      personas.value[currentPlayer.value].vidas--
      socket.emit('updateVidas', personas.value)     
      personas.value.forEach(persona => {
        if(persona.vidas === 0){
          noLive.value = [...noLive.value, persona.name]
            noLive.value = new Set(noLive.value)
            noLive.value =  [...noLive.value]
            socket.emit('updateNoLive', noLive.value)
          }
        });
      }
    }, 1000);
    //END
  }
  

  socket.on('count', (data)=>{
    time.value = data
  })
  
const resetTimer = () => {
  clearInterval(countdownInterval);
  timer()
};

watch(palabra, ()=>{
  if(palabra.value.length <20){
    socket.emit("online", palabra.value)
  }
})

socket.on('endGame', ()=>{
  endGame()
})

const endGame = ()=>{
  clearInterval(animate)
  clearInterval(countdownInterval);
  personas.value.forEach(person =>{
    if(!noLive.value.includes(person.name)){
      console.log(noLive.value);
      console.log(person.name);
      return ganador.value = person.name
    }
  })
  ctx.value.clearRect(0,0,canvas.value?.width, canvas.value?.height)
  ctx.value.font = '30px Arial'
  ctx.value.fillStyle= 'white'
  ctx.value.textAlign = 'center'
  /*    ctx.value.fillRect(x-130,y+40,300, 25) */ 
  ctx.value.fillText('Ganador: ' + ganador.value, centerX,centerY)
  ctx.value.clearRect(0,0,canvas.value?.width, canvas.value?.height)
  ctx.value.fillText('Ganador: ' + ganador.value, centerX,centerY+200)

  const winer = new Image();
  winer.src = win
  winer.onload= ()=>{
    ctx.value.drawImage(winer,centerX-100,centerY-200,winer.width/7,winer.height/7)
  }
  
  setTimeout(()=>{
    location.reload()
    /* router.push(`/`) */
  }, 5000)
}

});




const salida = ()=>{
  clearInterval(countdownInterval);
  socket.emit('salida', props.name)
}

onUnmounted(()=>{
  
  salida()
})

const init = ()=>{
  socket.emit('inicio');
}

const endTurn = () => {
  clearInterval(countdownInterval);
  socket.emit('endTurn');
};
const handleSubmit = ()=>{
  palabra.value= palabra.value.toLowerCase()
  if(palabra.value.includes(silaba.value)){
    endTurn()
    socket.emit("generate")
    palabra.value = ''
    socket.emit("siguiente", contador.value)
  }else{
    errors.volume = 0.8
    errors.play()
  }
}


</script>

<template>
  <div>
    <div>
      <h3>Tiempo: {{ time }}</h3>
      <p v-if="props.name === turno">Es tu turno </p>
      <p v-else>Es turno de: {{ turno }}</p>
      <button v-if="props.name === 'Jose'" @click="init">Comenzar</button>
      <canvas ref="canvas" width="1000" height="600" style="border: 1px solid white;"></canvas>
    </div>
    <p>Palabra: {{ palVivo }}</p>
      <fieldset id="field">
        <input placeholder="Ingresa palabra" v-model="palabra"/>
        <button @click="handleSubmit">Enviar</button>
        <!-- <button @click="">Terminar Turno</button> -->
        <router-link @click="salida" to="/"><button >Salir</button></router-link>
      </fieldset>
  </div>
</template>

<style scoped>
</style>
